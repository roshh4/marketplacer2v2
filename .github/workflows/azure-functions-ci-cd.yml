name: Azure Functions CI/CD

on:
  push:
    branches:
      - main
      - develop
    paths:
      - 'azure-functions/**'
      - 'terraform/modules/azure-functions/**'
      - '.github/workflows/azure-functions-ci-cd.yml'
  pull_request:
    branches:
      - main
      - develop
    paths:
      - 'azure-functions/**'
      - 'terraform/modules/azure-functions/**'

env:
  AZURE_FUNCTIONAPP_PACKAGE_PATH: './azure-functions/ai-generated-description'
  PYTHON_VERSION: '3.9'

jobs:
  # Test and validate the function code
  test:
    runs-on: ubuntu-latest
    steps:
    - name: 'Checkout GitHub Action'
      uses: actions/checkout@v4

    - name: Setup Python ${{ env.PYTHON_VERSION }} Environment
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: 'Install dependencies'
      shell: bash
      run: |
        cd ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov requests-mock

    - name: 'Run unit tests'
      shell: bash
      run: |
        cd ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
        # Create a simple test if none exists
        if [ ! -f test_function_unit.py ]; then
          cat > test_function_unit.py << 'EOF'
        import pytest
        from unittest.mock import patch, MagicMock
        import sys
        import os
        sys.path.append(os.path.dirname(os.path.abspath(__file__)))
        
        def test_template_service():
            """Test template description generation"""
            from function_app import TemplateService
            
            result = TemplateService.generate_description("Test Laptop", "Electronics")
            assert "Test Laptop" in result
            assert len(result) > 0
            
        def test_image_processor():
            """Test MIME type detection"""
            from function_app import ImageProcessor
            
            assert ImageProcessor.get_mime_type_from_filename("test.jpg") == "image/jpeg"
            assert ImageProcessor.get_mime_type_from_filename("test.png") == "image/png"
            assert ImageProcessor.get_mime_type_from_filename("test.webp") == "image/webp"
        EOF
        fi
        python -m pytest test_function_unit.py -v --cov=function_app

    - name: 'Lint code'
      shell: bash
      run: |
        cd ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
        pip install flake8
        flake8 function_app.py --max-line-length=120 --ignore=E501,W503

  # Terraform validation and planning
  terraform-validate:
    runs-on: ubuntu-latest
    needs: test
    steps:
    - name: 'Checkout'
      uses: actions/checkout@v4

    - name: 'Setup Terraform'
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0

    - name: 'Terraform Format Check'
      run: |
        cd terraform
        terraform fmt -check -recursive

    - name: 'Terraform Init'
      run: |
        cd terraform
        terraform init -backend=false

    - name: 'Terraform Validate'
      run: |
        cd terraform
        terraform validate

  # Deploy to Development
  deploy-dev:
    runs-on: ubuntu-latest
    needs: [test, terraform-validate]
    if: github.ref == 'refs/heads/develop'
    environment: development
    steps:
    - name: 'Checkout GitHub Action'
      uses: actions/checkout@v4

    - name: 'Login to Azure'
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: 'Setup Terraform'
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0

    - name: 'Terraform Init'
      run: |
        cd terraform
        terraform init \
          -backend-config="resource_group_name=${{ secrets.TF_STATE_RESOURCE_GROUP }}" \
          -backend-config="storage_account_name=${{ secrets.TF_STATE_STORAGE_ACCOUNT }}" \
          -backend-config="container_name=${{ secrets.TF_STATE_CONTAINER }}" \
          -backend-config="key=dev.tfstate"

    - name: 'Terraform Plan'
      run: |
        cd terraform
        terraform plan \
          -var-file="environments/dev.tfvars" \
          -var="db_admin_password=${{ secrets.DB_ADMIN_PASSWORD_DEV }}" \
          -var="gemini_api_key=${{ secrets.GEMINI_API_KEY }}" \
          -var="content_safety_key=${{ secrets.CONTENT_SAFETY_KEY_DEV }}" \
          -out=tfplan

    - name: 'Terraform Apply'
      run: |
        cd terraform
        terraform apply -auto-approve tfplan

    - name: 'Get Function App Name'
      id: get-function-name
      run: |
        cd terraform
        FUNCTION_NAME=$(terraform output -raw function_app_name)
        echo "function_name=$FUNCTION_NAME" >> $GITHUB_OUTPUT

    - name: Setup Python ${{ env.PYTHON_VERSION }} Environment
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: 'Deploy Azure Function'
      uses: Azure/functions-action@v1
      with:
        app-name: ${{ steps.get-function-name.outputs.function_name }}
        package: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
        publish-profile: ${{ secrets.AZURE_FUNCTIONAPP_PUBLISH_PROFILE_DEV }}

    - name: 'Run Integration Tests'
      shell: bash
      run: |
        cd ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
        # Wait for deployment to complete
        sleep 30
        
        # Get function URL from Terraform output
        cd ../../terraform
        FUNCTION_URL=$(terraform output -raw function_app_url)
        
        # Test health endpoint
        curl -f "$FUNCTION_URL/api/health" || exit 1
        
        # Test AI status endpoint
        curl -f "$FUNCTION_URL/api/ai-status" || exit 1
        
        echo "✅ Integration tests passed for development environment"

  # Deploy to Staging (from main branch)
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [test, terraform-validate]
    if: github.ref == 'refs/heads/main'
    environment: staging
    steps:
    - name: 'Checkout GitHub Action'
      uses: actions/checkout@v4

    - name: 'Login to Azure'
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: 'Setup Terraform'
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0

    - name: 'Terraform Init'
      run: |
        cd terraform
        terraform init \
          -backend-config="resource_group_name=${{ secrets.TF_STATE_RESOURCE_GROUP }}" \
          -backend-config="storage_account_name=${{ secrets.TF_STATE_STORAGE_ACCOUNT }}" \
          -backend-config="container_name=${{ secrets.TF_STATE_CONTAINER }}" \
          -backend-config="key=staging.tfstate"

    - name: 'Terraform Plan'
      run: |
        cd terraform
        terraform plan \
          -var-file="environments/staging.tfvars" \
          -var="db_admin_password=${{ secrets.DB_ADMIN_PASSWORD_STAGING }}" \
          -var="gemini_api_key=${{ secrets.GEMINI_API_KEY }}" \
          -var="content_safety_key=${{ secrets.CONTENT_SAFETY_KEY_STAGING }}" \
          -out=tfplan

    - name: 'Terraform Apply'
      run: |
        cd terraform
        terraform apply -auto-approve tfplan

    - name: 'Get Function App Name'
      id: get-function-name
      run: |
        cd terraform
        FUNCTION_NAME=$(terraform output -raw function_app_name)
        echo "function_name=$FUNCTION_NAME" >> $GITHUB_OUTPUT

    - name: Setup Python ${{ env.PYTHON_VERSION }} Environment
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: 'Deploy to Staging Slot'
      uses: Azure/functions-action@v1
      with:
        app-name: ${{ steps.get-function-name.outputs.function_name }}
        slot-name: 'staging'
        package: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
        publish-profile: ${{ secrets.AZURE_FUNCTIONAPP_PUBLISH_PROFILE_STAGING }}

    - name: 'Run Staging Tests'
      shell: bash
      run: |
        cd ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
        # Wait for deployment to complete
        sleep 30
        
        # Get staging function URL from Terraform output
        cd ../../terraform
        STAGING_URL=$(terraform output -raw function_staging_url)
        
        # Test health endpoint
        curl -f "$STAGING_URL/api/health" || exit 1
        
        # Test AI status endpoint
        curl -f "$STAGING_URL/api/ai-status" || exit 1
        
        # Test description generation
        curl -f -X POST "$STAGING_URL/api/generate-description" \
          -H "Content-Type: application/json" \
          -d '{"title": "Test Laptop", "category": "Electronics"}' || exit 1
        
        echo "✅ Staging tests passed"

  # Deploy to Production (manual approval required)
  deploy-production:
    runs-on: ubuntu-latest
    needs: deploy-staging
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
    - name: 'Checkout GitHub Action'
      uses: actions/checkout@v4

    - name: 'Login to Azure'
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: 'Setup Terraform'
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.5.0

    - name: 'Terraform Init'
      run: |
        cd terraform
        terraform init \
          -backend-config="resource_group_name=${{ secrets.TF_STATE_RESOURCE_GROUP }}" \
          -backend-config="storage_account_name=${{ secrets.TF_STATE_STORAGE_ACCOUNT }}" \
          -backend-config="container_name=${{ secrets.TF_STATE_CONTAINER }}" \
          -backend-config="key=prod.tfstate"

    - name: 'Terraform Plan'
      run: |
        cd terraform
        terraform plan \
          -var-file="environments/prod.tfvars" \
          -var="db_admin_password=${{ secrets.DB_ADMIN_PASSWORD_PROD }}" \
          -var="gemini_api_key=${{ secrets.GEMINI_API_KEY }}" \
          -var="content_safety_key=${{ secrets.CONTENT_SAFETY_KEY_PROD }}" \
          -out=tfplan

    - name: 'Terraform Apply'
      run: |
        cd terraform
        terraform apply -auto-approve tfplan

    - name: 'Get Function App Name'
      id: get-function-name
      run: |
        cd terraform
        FUNCTION_NAME=$(terraform output -raw function_app_name)
        echo "function_name=$FUNCTION_NAME" >> $GITHUB_OUTPUT

    - name: Setup Python ${{ env.PYTHON_VERSION }} Environment
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: 'Deploy Azure Function to Production'
      uses: Azure/functions-action@v1
      with:
        app-name: ${{ steps.get-function-name.outputs.function_name }}
        package: ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
        publish-profile: ${{ secrets.AZURE_FUNCTIONAPP_PUBLISH_PROFILE_PROD }}

    - name: 'Run Production Smoke Tests'
      shell: bash
      run: |
        cd ${{ env.AZURE_FUNCTIONAPP_PACKAGE_PATH }}
        # Wait for deployment to complete
        sleep 30
        
        # Get production function URL from Terraform output
        cd ../../terraform
        PROD_URL=$(terraform output -raw function_app_url)
        
        # Test health endpoint
        curl -f "$PROD_URL/api/health" || exit 1
        
        # Test AI status endpoint
        curl -f "$PROD_URL/api/ai-status" || exit 1
        
        echo "✅ Production smoke tests passed"
        echo "🚀 Azure Function deployed to production: $PROD_URL"
