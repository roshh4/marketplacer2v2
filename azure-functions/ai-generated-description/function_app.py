import azure.functions as func
import logging
import json
import os
import base64
import tempfile
import uuid
from datetime import datetime
from typing import List, Dict, Any, Optional, Tuple
import requests
import mimetypes
from pathlib import Path

# Initialize the Azure Functions app
app = func.FunctionApp()

# Gemini API Configuration
GEMINI_API_KEY = os.environ.get('GEMINI_API_KEY')
GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent"

class GeminiService:
    """Service class for interacting with Google Gemini Pro Vision API"""
    
    @staticmethod
    def is_configured() -> bool:
        """Check if Gemini API is properly configured"""
        return GEMINI_API_KEY is not None and GEMINI_API_KEY != ""
    
    @staticmethod
    def generate_description_from_files(title: str, category: str, image_files: List[Dict]) -> Tuple[str, str]:
        """Generate product description from uploaded image files"""
        if not GeminiService.is_configured():
            logging.warning("Gemini API not configured, using template fallback")
            return TemplateService.generate_description(title, category), "template-fallback"
        
        try:
            # Create prompt for Gemini
            prompt = f"""You are an expert at writing marketplace product descriptions for college students.

Product Information:
- Title: "{title}"
- Category: "{category}"
- Target Audience: College students buying/selling items

Instructions:
1. Analyze the uploaded images to identify key features, condition, and appeal
2. Write 2-3 sentences that are engaging and informative
3. Highlight what makes this item valuable for students
4. Mention visible condition/quality from images
5. Use friendly, conversational tone suitable for college marketplace
6. Focus on practical benefits for student life
7. Be specific about what you can see in the images

Generate an appealing product description:"""

            # Build request parts
            parts = [{"text": prompt}]
            
            # Add images to request
            for image_file in image_files:
                if 'data' in image_file and 'mime_type' in image_file:
                    parts.append({
                        "inline_data": {
                            "mime_type": image_file['mime_type'],
                            "data": image_file['data']
                        }
                    })
            
            # Create Gemini request
            request_data = {
                "contents": [{"parts": parts}],
                "generationConfig": {
                    "temperature": 0.7,
                    "maxOutputTokens": 150,
                    "topP": 0.8,
                    "topK": 40
                }
            }
            
            # Make API call
            headers = {"Content-Type": "application/json"}
            url = f"{GEMINI_API_URL}?key={GEMINI_API_KEY}"
            
            response = requests.post(url, json=request_data, headers=headers, timeout=30)
            
            if response.status_code != 200:
                raise Exception(f"Gemini API returned status {response.status_code}: {response.text}")
            
            result = response.json()
            
            if not result.get('candidates') or not result['candidates'][0].get('content', {}).get('parts'):
                raise Exception("No description generated by Gemini")
            
            description = result['candidates'][0]['content']['parts'][0]['text'].strip()
            logging.info(f"âœ¨ Generated description with Gemini: {description}")
            
            return description, "gemini-pro-vision"
            
        except Exception as e:
            logging.warning(f"âš ï¸ Gemini API failed: {e}, falling back to template")
            return TemplateService.generate_description(title, category), "template-fallback"
    
    @staticmethod
    def generate_description_from_urls(title: str, category: str, image_urls: List[str]) -> Tuple[str, str]:
        """Generate product description from image URLs"""
        if not GeminiService.is_configured():
            logging.warning("Gemini API not configured, using template fallback")
            return TemplateService.generate_description(title, category), "template-fallback"
        
        try:
            # Download and encode images
            image_files = []
            for url in image_urls:
                try:
                    image_data, mime_type = ImageProcessor.download_and_encode_image(url)
                    image_files.append({
                        'data': image_data,
                        'mime_type': mime_type
                    })
                except Exception as e:
                    logging.warning(f"Failed to process image URL {url}: {e}")
                    continue
            
            if not image_files:
                logging.info("No valid images processed from URLs, using template")
                return TemplateService.generate_description(title, category), "template-fallback"
            
            return GeminiService.generate_description_from_files(title, category, image_files)
            
        except Exception as e:
            logging.warning(f"âš ï¸ Failed to process image URLs: {e}, falling back to template")
            return TemplateService.generate_description(title, category), "template-fallback"


class TemplateService:
    """Service class for template-based description generation"""
    
    TEMPLATES = {
        "Electronics": "Great {title} in good condition, perfect for students who need reliable technology for their studies and daily use.",
        "Books": "Well-maintained {title}, ideal for students looking to save money on textbooks while getting quality educational materials.",
        "Furniture": "Functional {title} in decent condition, perfect for dorm rooms or student apartments. Great value for money.",
        "Clothing": "Stylish {title} in good condition, perfect for students looking to expand their wardrobe on a budget.",
        "Sports": "Quality {title} ready for action, great for students who want to stay active without breaking the bank.",
        "default": "Quality {title} in good condition, perfect for students looking for great value and reliable performance."
    }
    
    @staticmethod
    def generate_description(title: str, category: str) -> str:
        """Generate a template-based product description"""
        template = TemplateService.TEMPLATES.get(category, TemplateService.TEMPLATES["default"])
        return template.format(title=title)


class ImageProcessor:
    """Service class for image processing operations"""
    
    @staticmethod
    def process_uploaded_file(file_content: bytes, filename: str) -> Tuple[str, str]:
        """Process uploaded file and return base64 data and mime type"""
        # Encode to base64
        image_base64 = base64.b64encode(file_content).decode('utf-8')
        
        # Determine MIME type from filename
        mime_type = ImageProcessor.get_mime_type_from_filename(filename)
        
        return image_base64, mime_type
    
    @staticmethod
    def download_and_encode_image(image_url: str) -> Tuple[str, str]:
        """Download image from URL and return base64 data and mime type"""
        response = requests.get(image_url, timeout=30)
        if response.status_code != 200:
            raise Exception(f"Failed to download image, status: {response.status_code}")
        
        # Encode to base64
        image_base64 = base64.b64encode(response.content).decode('utf-8')
        
        # Get MIME type from Content-Type header or URL
        mime_type = response.headers.get('Content-Type', '')
        if not mime_type:
            mime_type = ImageProcessor.get_mime_type_from_url(image_url)
        
        return image_base64, mime_type
    
    @staticmethod
    def get_mime_type_from_filename(filename: str) -> str:
        """Get MIME type from filename"""
        filename_lower = filename.lower()
        if filename_lower.endswith('.png'):
            return 'image/png'
        elif filename_lower.endswith('.webp'):
            return 'image/webp'
        elif filename_lower.endswith('.gif'):
            return 'image/gif'
        else:
            return 'image/jpeg'  # default for jpg, jpeg
    
    @staticmethod
    def get_mime_type_from_url(url: str) -> str:
        """Get MIME type from URL extension"""
        url_lower = url.lower()
        if '.png' in url_lower:
            return 'image/png'
        elif '.webp' in url_lower:
            return 'image/webp'
        elif '.gif' in url_lower:
            return 'image/gif'
        else:
            return 'image/jpeg'  # default


@app.route(route="generate-description", methods=["POST"])
def generate_description(req: func.HttpRequest) -> func.HttpResponse:
    """
    Azure Function to generate AI-powered product descriptions
    
    Accepts either:
    1. JSON request with title, category, and image_urls
    2. Multipart form data with title, category, and uploaded image files
    """
    start_time = datetime.now()
    
    try:
        logging.info("ðŸ¤– AI Description generation request received")
        
        # Check content type to determine request format
        content_type = req.headers.get('content-type', '').lower()
        
        if content_type.startswith('multipart/form-data'):
            # Handle multipart form data (uploaded files)
            return handle_multipart_request(req, start_time)
        else:
            # Handle JSON request (image URLs)
            return handle_json_request(req, start_time)
            
    except Exception as e:
        logging.error(f"âŒ Error in generate_description: {str(e)}")
        processing_time = (datetime.now() - start_time).total_seconds()
        
        return func.HttpResponse(
            json.dumps({
                "success": False,
                "error": f"Internal server error: {str(e)}",
                "processing_time": f"{processing_time:.2f}s"
            }),
            status_code=500,
            headers={"Content-Type": "application/json"}
        )


def handle_json_request(req: func.HttpRequest, start_time: datetime) -> func.HttpResponse:
    """Handle JSON request with image URLs"""
    try:
        # Parse JSON request
        req_body = req.get_json()
        if not req_body:
            return func.HttpResponse(
                json.dumps({
                    "success": False,
                    "error": "Invalid JSON request body"
                }),
                status_code=400,
                headers={"Content-Type": "application/json"}
            )
        
        # Extract required fields
        title = req_body.get('title', '').strip()
        category = req_body.get('category', '').strip()
        image_urls = req_body.get('image_urls', [])
        
        # Validate required fields
        if not title or not category:
            return func.HttpResponse(
                json.dumps({
                    "success": False,
                    "error": "Title and category are required"
                }),
                status_code=400,
                headers={"Content-Type": "application/json"}
            )
        
        logging.info(f"ðŸ¤– Processing JSON request: Title='{title}', Category='{category}', Images={len(image_urls)}")
        
        # Generate description
        if image_urls:
            description, model_used = GeminiService.generate_description_from_urls(title, category, image_urls)
        else:
            logging.info("â„¹ï¸ No images provided, using template generation")
            description, model_used = TemplateService.generate_description(title, category), "template-fallback"
        
        processing_time = (datetime.now() - start_time).total_seconds()
        
        logging.info(f"âœ¨ Generated description in {processing_time:.2f}s using {model_used}: {description}")
        
        return func.HttpResponse(
            json.dumps({
                "success": True,
                "description": description,
                "model_used": model_used,
                "processing_time": f"{processing_time:.2f}s"
            }),
            status_code=200,
            headers={"Content-Type": "application/json"}
        )
        
    except Exception as e:
        logging.error(f"âŒ Error handling JSON request: {str(e)}")
        processing_time = (datetime.now() - start_time).total_seconds()
        
        return func.HttpResponse(
            json.dumps({
                "success": False,
                "error": f"Failed to process request: {str(e)}",
                "processing_time": f"{processing_time:.2f}s"
            }),
            status_code=500,
            headers={"Content-Type": "application/json"}
        )


def handle_multipart_request(req: func.HttpRequest, start_time: datetime) -> func.HttpResponse:
    """Handle multipart form data request with uploaded files"""
    try:
        # Get form data
        form_data = {}
        files = []
        
        # Parse multipart data manually (Azure Functions limitation)
        # This is a simplified approach - in production, you might want to use a more robust parser
        body = req.get_body()
        
        # For now, return an error suggesting to use JSON format
        # Full multipart parsing in Azure Functions requires additional libraries
        return func.HttpResponse(
            json.dumps({
                "success": False,
                "error": "Multipart form data not fully supported in this version. Please use JSON format with image URLs or base64 encoded images.",
                "suggestion": "Send a POST request with JSON body containing 'title', 'category', and 'image_urls' fields."
            }),
            status_code=400,
            headers={"Content-Type": "application/json"}
        )
        
    except Exception as e:
        logging.error(f"âŒ Error handling multipart request: {str(e)}")
        processing_time = (datetime.now() - start_time).total_seconds()
        
        return func.HttpResponse(
            json.dumps({
                "success": False,
                "error": f"Failed to process multipart request: {str(e)}",
                "processing_time": f"{processing_time:.2f}s"
            }),
            status_code=500,
            headers={"Content-Type": "application/json"}
        )


@app.route(route="ai-status", methods=["GET"])
def get_ai_status(req: func.HttpRequest) -> func.HttpResponse:
    """
    Get AI service status and configuration information
    """
    try:
        status = {
            "gemini_configured": GeminiService.is_configured(),
            "timestamp": datetime.now().isoformat(),
            "models_available": [
                "gemini-pro-vision",
                "template-fallback"
            ],
            "supported_formats": [
                "image/jpeg",
                "image/png", 
                "image/webp",
                "image/gif"
            ],
            "max_images": 10,
            "service": "Azure Functions AI Description Generator"
        }
        
        return func.HttpResponse(
            json.dumps(status),
            status_code=200,
            headers={"Content-Type": "application/json"}
        )
        
    except Exception as e:
        logging.error(f"âŒ Error getting AI status: {str(e)}")
        return func.HttpResponse(
            json.dumps({
                "error": f"Failed to get status: {str(e)}"
            }),
            status_code=500,
            headers={"Content-Type": "application/json"}
        )


@app.route(route="health", methods=["GET"])
def health_check(req: func.HttpRequest) -> func.HttpResponse:
    """
    Simple health check endpoint
    """
    return func.HttpResponse(
        json.dumps({
            "status": "healthy",
            "timestamp": datetime.now().isoformat(),
            "service": "AI Description Generator"
        }),
        status_code=200,
        headers={"Content-Type": "application/json"}
    )
